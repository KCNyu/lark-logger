package main

import (
	"fmt"
	"log"
	"time"

	larklogger "github.com/KCNyu/lark-logger"
)

func main() {
	// Get webhook URL from environment variable
	webhookURL := larklogger.GetWebhookURL()

	// Check if running in test mode
	if larklogger.IsTestEnvironment() {
		log.Println("‚ö†Ô∏è  Running in TEST MODE - messages will not be sent to real Lark webhook")
		log.Printf("Test webhook URL: %s", webhookURL)
	} else {
		log.Println("üöÄ Running in PRODUCTION MODE - messages will be sent to Lark")
	}

	// Simplified API: Create logger directly with webhook URL and options
	logger := larklogger.New(
		webhookURL,
		larklogger.WithTimeout(10*time.Second),
		larklogger.WithRetry(3, 1*time.Second),
		larklogger.WithService("api-gateway"),
		larklogger.WithEnv("production"),
		larklogger.WithHostname("web-server-01"),
		larklogger.WithTitle("üöÄ System Monitor"),
	)

	// Alternative: Traditional two-step approach (still supported)
	// client := larklogger.NewClient(webhookURL, clientOpts...)
	// logger := larklogger.NewLogger(client, loggerOpts...)

	// Send Info level log with rich context (traditional way)
	logger.Info("API Gateway initialized successfully", map[string]interface{}{
		"port":     8080,
		"version":  "2.1.0",
		"features": []string{"authentication", "rate_limiting", "metrics"},
		"config": map[string]interface{}{
			"database": "postgresql",
			"cache":    "redis",
			"ssl":      true,
		},
		"uptime": "0s",
	})

	// Send logs using new Infof/Warnf/Errorf format (simplified)
	logger.Infof("Service health check", "status", "healthy", "response_time", "120ms", "uptime", "2h30m")
	logger.Warnf("Memory usage approaching threshold", "usage", "87%", "threshold", "85%", "recommendation", "consider horizontal scaling")
	logger.Errorf("Database connection pool exhausted", "error", "connection timeout after 30s", "retry_count", 3, "pool_size", 20)

	// Send simple text message using logger
	// Note: For text messages, you can still create a separate client if needed
	// client := larklogger.NewClient(webhookURL, clientOpts...)
	// err := client.SendText("üöÄ Lark Logger Demo - All systems operational!")

	// Or use logger for structured messages
	logger.Info("üöÄ Lark Logger Demo - All systems operational!", map[string]interface{}{
		"demo":   true,
		"status": "operational",
	})

	// Build and send custom enhanced card (example of advanced usage)
	// card := larklogger.NewCardBuilder().
	//     SetHeader("üéâ System Health Report", "green").
	//     AddSection("**Comprehensive system status overview**\n\nGenerated by Lark Logger SDK").
	//     AddKeyValueList("Core Features", map[string]interface{}{
	//         "Enhanced formatting": "‚úÖ",
	//         "Multi-level logging": "‚úÖ",
	//         "Structured data":     "‚úÖ",
	//         "Retry mechanism":     "‚úÖ",
	//         "Mobile optimization": "‚úÖ",
	//     }).
	//     AddStatusBadge("success", "All monitoring systems operational").
	//     AddMetricsGrid("Performance Metrics", map[string]interface{}{
	//         "CPU Usage":     "45%",
	//         "Memory":        "67%",
	//         "Disk Space":    "23%",
	//         "Network I/O":   "12%",
	//         "Response Time": "120ms",
	//     }).
	//     Build()

	// For custom cards, you can still create a separate client if needed
	// client := larklogger.NewClient(webhookURL, clientOpts...)
	// err = client.SendCard(card)
	// if err != nil {
	//     log.Printf("Failed to send custom card: %v", err)
	// }

	// Or use logger for structured messages instead
	logger.Info("System Health Report", map[string]interface{}{
		"Memory":        "67%",
		"Disk Space":    "23%",
		"Network I/O":   "12%",
		"Response Time": "120ms",
		"Report Type":   "Health Check",
	})

	fmt.Println("üéä All messages sent successfully! Check your Lark workspace.")
}
